# User Manager (Flask)

Flask-App-User-Manager is a web application that provides user management (CRUD), roles, and basic authentication.
The main objective is to deliver a realistic multi-environment architecture (dev and prod) with end-to-end CI/CD using:

- AWS (EC2 + RDS + VPC)
- Terraform for infrastructure provisioning
- Ansible for configuration and deployment
- Jenkins Multibranch Pipeline
- Splunk for real-time monitoring and logging

This project serves as a hands-on base for automation, monitoring, testing, and DevOps best practices.

---

## Project Architecture

### Application Layer
- Python 3.x  
- Flask  
- SQLAlchemy ORM  
- PostgreSQL  
- Jinja2 templates  
- Structured logging  

### AWS Architecture (Provisioned via FUM-TF)
- EC2 instance for the Flask application  
- EC2 (or RDS) instance for PostgreSQL  
- VPC with 2 public subnets  
- Separate Security Groups per environment  
- S3 buckets for Terraform remote state  
- Jenkins EC2 instance for CI/CD  

### CI/CD Flow
1. GitHub Pull Request → Jenkins PR Pipeline Trigger  
2. Terraform Plan (no apply on PR)  
3. Ansible Test Playbook executed on PR  
4. Merge into `develop`  
5. Jenkins: Terraform Apply + Ansible Deploy  
6. Log ingestion into Splunk for monitoring  

### Monitoring
- Splunk HEC integration  
- Real-time ingestion of:
  - syslog
 

---


## Project Structure

```bash
Flask-App-User-Manager/
│
├── app.py
├── models.py
├── requirements.txt
├── .env.example
│
├── templates/
│ ├── index.html
│ └── layout.html
│
├── static/
│ ├── css/
│ └── js/
│
├── ansible/
│ ├── inventory/
│ │ ├── dev
│ │ └── prod
│ │
│ ├── roles/
│ │ └── app/
│ │ ├── tasks/
│ │ │ ├── main.yml
│ │ │ ├── install.yml
│ │ │ ├── service.yml
│ │ │ └── deploy.yml
│ │ │
│ │ ├── templates/
│ │ │ └── flaskapp.service.j2
│ │ │
│ │ ├── files/
│ │ └── vars/
│ │ └── main.yml
│ │
│ ├── playbooks/
│ │ ├── deploy.yml
│ │ ├── setup_app.yml
│ │ └── test_playbook.yml
│ │
│ └── ansible.cfg
│
├── scripts/
├── logs/
│
└── README.md
```

---

## Loca Installation and Setup (versión 1.0 and opcional)

1. **Clone the repository**:

```bash
git clone https://github.com/<your-username>/<your-repo>.git
cd <your-repo>
```

2. Run the local setup script:
./setup.sh
if you are using WSL you may need to run:

```bash
sudo apt update && sudo apt install dos2unix -y 
dos2unix setup.sh
```

4. Open the container in Docker Desktop and visit http://127.0.0.1:5000
 in your browser.

---

## AWS Deployment (DevOps Pipeline)

The AWS deployment is managed entirely through the **FUM-TF** repository using **Terraform** and **Ansible**.


## Deployment Flow

1. **Terraform provisioning**
   - Creates the VPC and subnets  
   - Configures EC2 instances  
   - Sets up security groups  
   - Generates key pairs  
   - Creates IAM roles  

2. **Ansible connects to the EC2 application instance**
   - Uses the SSH key generated by Terraform

3. **Ansible clones this repository**
   - Retrieves the latest code from the specified branch (e.g., `develop`)

4. **Installs dependencies and creates a Python virtual environment**
   - Installs Python packages through `pip`
   - Creates and activates a dedicated virtual environment for the Flask app

5. **Registers a `systemd` service to run Flask**
   - Ensures the application runs as a background service
   - Enables automatic restart on failure
   - Ensures the app starts automatically after system reboot

6. **Starts the application**
   - Launches the Flask application 


---

### Enviroment Variables (Production)

| Variable     | Description               |
| ------------ | ------------------------- |
| **DB_USER**      | PostgreSQL username       |
| **DB_PASSWORD**  | PostgreSQL password       |
| **DB_HOST**      | Private IP of DB instance |
| **DB_PORT**      | Database port (5432)      |
| **DB_NAME**      | Database name             |
| **SPLUNK_URL**   | Splunk HEC endpoint       |
| **SPLUNK_TOKEN** | HEC token                 |
| **APP_ENV**      | dev/prod                  |
| **SECRET_KEY**   | Flask secret key          |

---

## CI/CD – Jenkins Multibranch Pipeline

The Jenkins pipeline includes:

- **Automatic detection of Pull Requests**
- **Ansible test execution** (validation only)
- **Terraform Plan**
- **Deployment triggered on merge to `develop`**
- **Splunk log forwarding**
- **Branch-based execution rules** (dev/prod separation)

---

### 🛠️ Ansible Role in This Project

The `ansible/` directory contains all automation required to configure and deploy the Flask application on AWS EC2 instances.  
Ansible is triggered through Jenkins as part of the CI/CD pipeline after Terraform provisions the infrastructure.

Ansible is responsible for:

- Installing system packages and Python dependencies  
- Creating and managing the virtual environment  
- Cloning the Flask-App-User-Manager repository into the EC2 instance  
- Deploying the application with its required settings  
- Creating and enabling the systemd service (`flaskapp.service`)  
- Managing environment variables for dev and prod  
- Validating deployments through test playbooks  
- Ensuring idempotent, repeatable deployments across environments  

This allows the deployment process to be fully automated, consistent, and environment-independent.



---

## Upcoming Improvements & Roadmap

### API Documentation (Swagger – Upcoming)

Planned improvements:
- `/docs` endpoint
- `/openapi.json` specification
- Route decorators for automatic documentation
- Basic authentication for documentation access

---

### Machine Learning (Roadmap)

Future ML enhancements:
- Log anomaly detection
- User behavior scoring
- Permission recommendation engine
- Error classification models

---

### Front-End (Roadmap)

Planned UI improvements:
- React-based front-end
- TailwindCSS or Material UI
- JWT authentication integration
- Admin dashboard with analytics

---

## Other improvements

- Implement real-time monitoring with **Splunk**
- Build a complete **testing environment**
- Improve **Jenkins integration** with GitHub



---

**Gerald Opitz 
**Matías Valladares 
